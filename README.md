# 4

Обяснете основните разлики между презареждане и презаписване на методи.

Методи с едно и също име, но различни сигнатури. [Презареждане на методи]
Може да се случи в същия клас или в негов подклас. [Презареждане на методи]
Може да се случи в подкласовете. [Презаписване на методи]
Трябва да има същия тип на връщана стойност. [Презаписване на методи]
При компилиране, според подадените параметри компилатора определя кой метод точно ще изпълни. [Презареждане на методи]
Модификатора за достъп не може да бъде по-ограничаващ. [Презаписване на методи]



Посочете кое е другото название, с което наричаме шаблонните класове в C#.

Generics

-----------------------------------------------------------------------------------------------------------

Дайте пример за шаблонен клас, който да се казва Кутия и тази кутия да може да съхранява всичко. В този клас създайте и един метод, който да добавя елемент в края на редицата.

class Box<T>
    {
        private List<T> items;

        public Box()
        {
            items = new List<T>();  
        }
        public void Add(T item)
        {
            this.items.Add(item);
        }
    }

-------------------------------------------------------------------------------------------------------------------------

Дайте пример за абстракция. Напишете примерен код, който:

Има класовете BaseEmployee, FullTimeEmployee и ContractEmployee.

Условието на задачата е всички работници да имат име, както и  метод CalculateSalary(int workingHours) - който ще изчислява заплатата за работника, като се приема параметър – брой изработени часове. 

Заплатата на FullTimeEmployee се изчислява по формулата: 250 + workingHours*10.80.

А заплатата на ContractEmployee по формулата: 250 + workingHours*20.

Спазвайте принципа за абстракция в обектно-ориентираното програмиране.

abstract class BaseEmployee
    {
        public string Name { get; set; }
        public abstract double CalculateSalary(int workingHours);
    }

    class FullTimeEmployee : BaseEmployee
    {
        public override double CalculateSalary(int workingHours)
        {
            return 250 + workingHours * 10.80;
        }
    }

    class ContractEmployee : BaseEmployee
    {
        public override double CalculateSalary(int workingHours)
        {
            return 250 + workingHours * 20;
        }
    }

--------------------------------------------------------------------------------------------------------------------------
Посочете какви са приликите и разликите между полиморфизъм и абстракция в обектно-ориентираното програмиране като поставите липсващите думи в текста.

Полиморфизмът може много да напомня на абстракцията, но в програми­рането се свързва най-вече с [пренаписването (override) ] на методи в [нас­ледените класове] с цел [промяна на оригиналното им поведение], насле­дено от базовия клас. Абстракцията се свързва със [създаването на интерфейс на компонент] или функционалност.

----------------------------------------------------------------------------------------------------------------------------
Свържете кои от характеристиките се отнасят за абстрактните класове, кои за интерфейсите.

Може да притежава полета и константи. [Абстрактни класове]

Е по-добър избор, ако множество имплементации споделят само сигнатурата на методите и нищо друго. [Интерфейси]

Не поддържа полета. [Интерфейси]

Е по-добър избор, ако множество имплементации са от сходен вид и имат общо поведение или статут. [Абстрактни класове]

Ако добавим нов метод, то имаме опцията да създадем имплементация по подразбиране и така съществуващият код ще може да работи коректно. [Абстрактни класове]

Ако добавим нов метод, то трябва да проследим всичките му имплементации и да дефинираме имплементация за новия метод. [Интерфейси]

------------------------------------------------------------------------------------------------------------------------
Създайте следната йерархия от класове и интерфейси.

abstract class Animal : IAnimal

    {

        private string name;

 

        protected Animal(string name)

        {

            Name = name;

        }

 

        public string Name

        {

            get { return name; }

            private set

            {

                if (string.IsNullOrEmpty(value) || string.IsNullOrWhiteSpace(value))

                {

                    throw new ArgumentException("Name can't be null or empty!");

                }

                name = value;

            }

        }

 

        public string Type {  }

       

        public void Perform()

        {

            Console.WriteLine($">>> {this.MakeNoise()}");

            Console.WriteLine($">>> {this.MakeTrick()}");

        }

 

        public override string ToString()

        {

            return base.ToString();

        }

    }

class Cat

    {

        public Cat(string name) : base(name)

        {

        }

 

        public override string MakeNoise()

        {

           

        }

 

        public override string MakeTrick()

        {

           

        }

 

    }

class Dog

    {

        public Dog(string name) : base(name)

        {

        }

 

        public override string MakeNoise()

        {

           

        }

 

        public override string MakeTrick()

        {

           

        }

    }


interface IAnimal

    {

        public string Type  get; }

        public string Name { get; }

        void Perform();

    }


interface IMakeNoise

    {

        string MakeNoise();

    }


interface IMakeTrick

    {

        string MakeTrick()

    }

class Program

    {

        static void Main(string[] args)

        {

            List<Cat> animals = new List<Cat>();

 

            int n = int.Parse(Console.ReadLine());

 

            for (int i = 0; i < n; i++)

            {

                string[] line = Console.ReadLine().Split();

                IAnimal animal = CreateAnimal(line);

                animals.Add(animal);

            }

 

            string trainerName = Console.ReadLine();

 

            Trainer trainer = null;

 

            string name = Console.ReadLine();

 

            while (name != "End")

            {

                IAnimal current = animals.Where(a => a.Name.Equals(name)).FirstOrDefault();

 

                if (current == null)

                {

                    Console.WriteLine("No such name in the Database!");

               

                else

                {

                    if (trainer == null)

                    {

                        trainer = new Trainer(trainerName, current);

                    }

                    trainer.Work(current);

                    trainer.Make();

                }

 

            }

        }

        private static IAnimal CreateAnimal(string[] line)

        {

            IAnimal animal = null;

            switch (line[0])

            {

                case "Cat":

                    animal = new Cat(line[1]);

                    break;

                case "Dog":

                    animal = new Dog(line[1]);

                    break;

            }

            return animal;

        }

    }

Trainer

    {

        private IAnimal entity;

        private string name;

 

        public Trainer(string name, IAnimal entity)

        {

            this.Name = name;

            this.Entity = entity;

        }

 

        public string Name

        {

            private set

            {

                if (string.IsNullOrEmpty(value) || string.IsNullOrWhiteSpace(value))

                {

                    throw new ArgumentException("Name can't be null or empty!");

                }

                name = value;

            }

        }

        public IAnimal Entity

        {

            get { return Еntity; }

            private set

            {

                entity = value;

            }

        }

 

        public void Work(IAnimal entity)

        {

            this.Entity = entity;

            Console.WriteLine($"Trainer {this.Name} works with {Entity}!");

        }

 

        public void Make()

        {

            this.Entity.Perform();

        }

    }

---------------------------------------------------------------------------------------------------------------------

Посочете кое от изброените твърдение е вярно за класовете в C#.


Можем да създаваме инстанции., Описва състоянието и поведението на обектите
  
  --------------------------------------------------------------------------------------------------------------------
  
  Открийте липсващите думи в текста:
  
  Възможността референция към [базов клас ] да сочи обект както от базовия, така и обект от някой от производните класове е в основата на реализацията на [полиморфизма ] в езика C#.

Кои от следните примери потвърждават това правило, ако имате следната йерархия class Cat : class Animal ?

Cat cat  = new Animal(); [не]

Animal animal = new Animal(); [да]

Animal animal = new Cat(); [да]

------------------------------------------------------------------------------------------------------
  
  Посочете по какъв начин указваме на даден метод от базовия клас, че искаме да презапишем неговото поведение.
  
  Чрез ключовата дума virtual.
  
  -------------------------------------------------------------------------------------------------------------
  
Дайте пример чрез код на C# за това как и къде бихте използвали презаписване на методи. 

 class Animal
{
        public virtual void MakeTrick()
        {
            Console.WriteLine("No trick...");
        }
}
class Dog : Animal
{
        public override void MakeTrick()
        {
            Console.WriteLine("Give a paw...");
        }
}

-------------------------------------------------------------------------------------------------------------
  
  Свържете кои от характеристиките се отнасят за абстракцията, кои за енкапсулацията.
  
  Получава се чрез модификаторите за достъп (private, public, protected, internal) [Енкапсулация]

Постига се чрез интерфейси и абстрактни класове. [Абстракция]

Процес на скриване на подробностите на имплементацията и показване само на функционалностите към потребителя. [Абстракция]

Използва се, за  да скрива кода и информацията в един компонент, за да я защити от външния свят. [Енкапсулация]

---------------------------------------------------------------------------------------------------------------------------
  
 Посочете кое от изброените твърдение е вярно за интерфейсите в C#.
  
  Предоставя договор, определящ как да се създаде обект, без да се интересува от спецификата на това как обекта ще прави нещата., Това е референтен тип и включва само абстрактни членове като събития, методи, свойства и т.н. и няма реализации за нито един от своите членове.
  
---------------------------------------------------------------------------------------------------------------------  
  
  Избройте четирите основни принципа на обектно-ориентираното програмиране.
  
  капсулация, наследяване, абстракция, полиморфизъм
  
  ---------------------------------------------------------------------------------------------------------------------
  
  Дефинирайте понятието полиморфизъм в обектно-ориентираното програмиране като попълните липсващите думи в текста.
  
  Полиморфизмът в обектно-ориентираното програмиране представлява свойството на обектите от един и същи [тип] да имат един и същи [интерфейс], но с [различна реализация] на този [интерфейс]. „Един [интерфейс], [множество от различни реализации]“. Чрез полиморфизма се постига по-голяма [абстракция ] и по-лесно [повторно използване] на кода.

-----------------------------------------------------------------------------------
  
  Дефинирайте термина полиморфизъм в обектно-ориентираното програмиране, като поставите липсващите думи в текста.
  
  Терминът полиморфизъм в обектно-ориентираното програмиране определя, че [едни и същи (еднотипни)] действия се реализират по [различен начин] в зависимост от обектите, върху които се прилагат. Такива действия се наричат [полиморфични]. За да се реализира [полиморфно действие], класовете на обектите, върху които се прилага това действие, трябва да имат [общ корен] т.е. да бъдат производни на [един и същи клас].
  
  -----------------------------------------------------------------------------------------------------------------------
  
  Имате следния код:

        public List<int> CreateList(int item, int count)
        {
            List<int> list = new List<int>();
            for (int i = 0; i < count; i++)
            {
                list.Add(item);
            }
        }

 Модифицирайте кода,така че методът да работи с всякакъв тип данни.
  
  public List<T> CreateList<T>(T item, int count)//2т
        {
            List<T> list = new List<T>();//2т
            for (int i = 0; i < count; i++)
            {
                list.Add(item);
            }
            return list;//2т
        }
  
  --------------------------------------------------------------------------
  
  Свържете кои от характеристиките се отнасят за абстрактните класове, кои за интерфейсите.
  
  Може да наследи само един абстрактен клас. [Абстракция]

Могат да предоставят целия код и/или само детайлите, които трябва да се презапишат. [Абстракция]

Може да имплементира няколко интерфейса. [И за двете ]

Може да съдържа модификатори за достъп. [Абстракция]

Не може да предоставя никакъв код, предоставя само описание. [Интерфейси]                        

Нямат модификатори за достъп. Всичко е публично по подразбиране. [Интерфейси]

  ----------------------------------------------
  
  ------------------------------------------
  
  ----------------------------------------------
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

